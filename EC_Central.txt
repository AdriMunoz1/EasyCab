import socket
import sqlite3
import sys
import threading
import time
from kafka import KafkaProducer, KafkaConsumer

AVAILABLE_TAXIS = []  # Lista para almacenar los taxis disponibles

def get_parameters():
    if len(sys.argv) != 4:
        print(f"Error: python3 EC_Central.py <Port Central> <IP Broker> <Port Broker>")
        sys.exit(1)

    port_central = int(sys.argv[1])
    ip_broker = sys.argv[2]
    port_broker = int(sys.argv[3])

    return port_central, ip_broker, port_broker

def get_ip():
    # Crear un socket para obtener la IP local
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    try:
        s.connect(("8.8.8.8", 80))  # Conéctate a un servidor público (Google DNS)
        ip_address = s.getsockname()[0]  # Obtén la dirección IP de la máquina
    finally:
        s.close()  # Cierra el socket

    return ip_address

def load_city_map(filename):
    city_map = [['' for _ in range(20)] for _ in range(20)]

    try:
        with open(filename, 'r') as file:
            for line in file:
                parts = line.strip().split()

                if len(parts) == 3:
                    id_site = parts[0]
                    coord_x = int(parts[1])
                    coord_y = int(parts[2])
                    city_map[coord_x][coord_y] = id_site

        print("Mapa de la ciudad cargado correctamente.")

    except Exception as e:
        print(f"Error al cargar el mapa de la ciudad: {e}")

    return city_map

# Función para actualizar el estado de un taxi en la base de datos
def update_taxi_status(status_taxi, id_taxi):
    try:
        connection = sqlite3.connect('taxis.db')
        cursor = connection.cursor()
        cursor.execute('UPDATE taxis SET estado = ? WHERE id = ?', (status_taxi, id_taxi))
        connection.commit()
        connection.close()
        print(f"Taxi {id_taxi} actualizado a {status_taxi}.")

    except sqlite3.Error as e:
        print(f"Error al actualizar el estado del taxi {id_taxi}: {e}")

# Función para enviar un comando al taxi (STOP, RESUME, DESTINATION, RETURN)
def send_command(sockets_taxi, command, id_taxi, destination=None):
    try:
        for socket_taxi in sockets_taxi:
            if socket_taxi["taxi_id"] == id_taxi:
                if command == "DESTINATION":
                    msg = f"{command}#{id_taxi}#{destination}"
                else:
                    msg = f"{command}#{id_taxi}"

                socket_taxi["socket"].send(msg.encode('utf-8'))
                print(f"Comando {command} enviado al taxi {id_taxi}")

                # Recibir respuesta del taxi solo para los comandos RESUME y DESTINATION
                if command in ["RESUME", "DESTINATION"]:
                    message = socket_taxi["socket"].recv(1024).decode('utf-8')

                    if message == 'OK' and command == 'STOP':
                        update_taxi_status("KO", id_taxi)
                    elif message == 'OK' and command == 'RESUME':
                        update_taxi_status("OK", id_taxi)

                return

        print(f"Taxi {id_taxi} no encontrado.")

    except Exception as e:
        print(f"Error al enviar el comando {command} al taxi {id_taxi}: {e}")

# Función para autenticar el taxi
def authenticate_taxi(id_taxi):
    try:
        connection = sqlite3.connect('taxis.db')
        cursor = connection.cursor()
        cursor.execute('SELECT * FROM taxis WHERE id = ?', (id_taxi,))
        taxi = cursor.fetchone()
        connection.close()

        if taxi:
            print(f"Taxi {id_taxi} autenticado correctamente.")
            update_taxi_status("OK", int(id_taxi))
            return True
        else:
            print(f"Taxi {id_taxi} no está registrado.")
            return False

    except sqlite3.Error as e:
        print(f"Error al autenticar el taxi: {e}")
        return False

# Función para manejar las conexiones con los taxis
def handle_taxis(sockets_taxi, socket_taxi, addr, city_map):
    id_taxi = None

    try:
        while True:
            request = socket_taxi.recv(1024).decode("utf-8")
            if not request:
                break

            if request.startswith("AUTH#"):
                id_taxi = request.split("#")[1]
                print(f"Autenticando taxi {id_taxi}")

                if authenticate_taxi(id_taxi):
                    response = "OK"
                    sockets_taxi.append({"socket": socket_taxi, "taxi_id": id_taxi})
                    AVAILABLE_TAXIS.append(id_taxi)  # Agregar taxi a la lista de disponibles
                else:
                    response = "KO"

                socket_taxi.send(response.encode("utf-8"))

            elif request.startswith("STOP#"):
                if id_taxi:
                    update_taxi_status("KO", id_taxi)
                    AVAILABLE_TAXIS.remove(id_taxi)  # Remover taxi de la lista de disponibles
                    print(f"Taxi {id_taxi} detenido y marcado como KO")
                else:
                    response = "Taxi no autenticado"
                    socket_taxi.send(response.encode("utf-8"))

            elif request.startswith("RESUME#"):
                if id_taxi:
                    update_taxi_status("OK", id_taxi)
                    AVAILABLE_TAXIS.append(id_taxi)  # Agregar taxi a la lista de disponibles
                    print(f"Taxi {id_taxi} reanudado y marcado como OK")
                else:
                    response = "Taxi no autenticado"
                    socket_taxi.send(response.encode("utf-8"))

            elif request.startswith("DESTINATION#"):
                if id_taxi:
                    # Aquí se asume que la petición incluye la posición del cliente y del destino
                    parts = request.split("#")
                    position_customer = (int(parts[2]), int(parts[3]))  # La posición del cliente
                    destination = (int(parts[4]), int(parts[5]))  # La posición del destino

                    print(f"Taxi {id_taxi} se dirige a la posición del cliente: {position_customer}")

                    # Simular el movimiento hacia la posición del cliente
                    time.sleep(2)  # Simula el tiempo de movimiento
                    print(f"Taxi {id_taxi} ha llegado a la posición del cliente: {position_customer}")

                    # Enviar la posición del destino al taxi
                    print(f"Enviando destino {destination} al taxi {id_taxi}")
                    send_command(sockets_taxi, "DESTINATION", id_taxi, destination)

                else:
                    response = "Taxi no autenticado"
                    socket_taxi.send(response.encode("utf-8"))

            elif request.startswith("RETURN#"):
                if id_taxi:
                    print(f"Taxi {id_taxi} regresando a la base")
                    # Regresar a la base
                    update_taxi_status("KO", id_taxi)
                    AVAILABLE_TAXIS.remove(id_taxi)  # Remover taxi de la lista de disponibles
                else:
                    response = "Taxi no autenticado"
                    socket_taxi.send(response.encode("utf-8"))

    except Exception as e:
        print(f"Error: {e}")

    finally:
        if id_taxi:
            update_taxi_status("KO", id_taxi)
            sockets_taxi[:] = [cs for cs in sockets_taxi if cs["taxi_id"] != id_taxi]
            AVAILABLE_TAXIS.remove(id_taxi)  # Remover taxi de la lista de disponibles
            print(f"Taxi {id_taxi} desconectado y marcado como KO.")
            socket_taxi.close()
            print("Socket del taxi cerrado.")

# Función para manejar las solicitudes de los clientes
def handle_customers(socket_customers):
    while True:
        request = socket_customers.recv(1024).decode('utf-8')
        if not request:
            break

        if request.startswith("REQUEST#"):
            # Aquí se asume que la petición incluye la posición del cliente
            parts = request.split("#")
            customer_position = (int(parts[1]), int(parts[2]))  # La posición del cliente
            print(f"Cliente solicita taxi desde la posición: {customer_position}")

            # Enviar el destino al primer taxi disponible
            if AVAILABLE_TAXIS:
                id_taxi = AVAILABLE_TAXIS[0]
                print(f"Asignando taxi {id_taxi} para recoger al cliente...")
                send_command(sockets_taxi, "DESTINATION", id_taxi, customer_position)
            else:
                print("No hay taxis disponibles en este momento.")

def start_server(port_central):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('', port_central))
    server_socket.listen(5)
    print(f"EC_Central escuchando en el puerto {port_central}...")

    sockets_taxi = []
    city_map = load_city_map("city_map.txt")

    try:
        while True:
            client_socket, addr = server_socket.accept()
            print(f"Conexión aceptada de {addr}")
            thread = threading.Thread(target=handle_taxis, args=(sockets_taxi, client_socket, addr, city_map))
            thread.start()

            # Para los clientes, se puede usar otra función o hilo
            customer_socket, addr_customer = server_socket.accept()
            print(f"Conexión aceptada de cliente en {addr_customer}")
            customer_thread = threading.Thread(target=handle_customers, args=(customer_socket,))
            customer_thread.start()

    except KeyboardInterrupt:
        print("Servidor detenido.")
    finally:
        server_socket.close()

if __name__ == "__main__":
    port_central, ip_broker, port_broker = get_parameters()
    ip_central = get_ip()
    print(f"IP del servidor central: {ip_central}")
    start_server(port_central)
